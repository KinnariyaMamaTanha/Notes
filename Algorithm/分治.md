>*递归地求解问题。每次都将问题转化为更小或更简单的问题，直到遇到基础情况*

在每层递归中，有如下三个步骤：
1. 分解：划分为规模更小的子问题
2. 解决：递归地解决子问题，当遇到基础情况时，直接解决
3. 合并：将子问题的解合并为原问题的解

# 一、递归式
>*递归式是描述分治的等式或不等式*

求解递归式的方法：
1. 代入法（先猜后证）
2. 递归树法：将递归式转化为递归树
3. 主方法：用于求解 $T(n)=aT(n/b)+f(n)$的界（问题被划分为b个同规模的子情况，每个子情况需要a的时间，分解和合并总用时为f(n)）
4. 母函数法

估计时i，常忽略取整及边界条件，通常没有影响

一般来说，分治法的时间消耗可以表示为：
$$
T(n) = 
\begin{cases}
\Theta(1) \quad n \le c\\
\sum_{i=1}^mT(n_i) + T(others) \quad n > c
\end{cases}
$$
其中 c 是一个固定的常数，$T(n_i)$表示第 i 种子情况所需时间，$T(others)$表示其他步骤所需时间。

## 1.1 代入法

1. 猜测
2. 使用归纳法证明(当猜测的结果很接近但不正确时，可以加强或减弱归纳假设)

如
$$
T(n) = 2T(n/2) + n
$$
可以归纳证明
$$
\exists c \in R, \thinspace T(n) < cn\lg n
$$
则有
$$
T(n) = O(n\lg n)
$$
也可以证明
$$
T(n)=\Omega(n\lg n)
$$
从而得出
$$
T(n)=\Theta(n\lg n)
$$

## 1.2 递归树法

画出递归树，对每层的所有结点求和，再对所有层求和，最终得到总代价。一般是通过递归树来猜测一个可能的解，再使用代入法求证。当然一般也需要在计算过程中进行一些估计（放弃取整，舍弃小量等）

例如，对递归式：
$$
T(n)=3T([n/4]) + \Theta(n^2)
$$
首先假设n为4的幂（放弃取整），并将$\Theta(n^2)$用 $cn^2$ 代替（其中c是一个常数），然后画出递归树：

![[递归树.png]]

此时可从上图中可得出，总时间代价为
$$
\begin{align}
T(n) &= cn^2 + \frac{3}{16}cn^2 + \ldots + (\frac{3}{16})^{\log_4 n-1}cn^2 + \Theta(n^{\log_4 3}) \\
&= \sum_{i=0}^{\log_4 n-1}(\cfrac{3}{16})^i cn^2 + \Theta(n^{\log_4 3}) \\
&= \frac{(\frac{3}{16})^{\log_4n}-1}{\frac{3}{16}-1}cn^2 + \Theta(n^{\log_4 3}) \\
&\thicksim cn^2
\end{align}
$$
同时还可以得出，若 $cn^2$ 确实是 $T(n)$ 的一个渐进上界，则必为 $T(n)$ 的一个渐进紧确界（因为根结点处就花费了 $cn^2$ 的时间，就有 $cn^2$ 为 $T(n)$ 的一个渐进下界）

## 1.3 主方法

1. 主方法专门用于求具有以下形式的递推公式的时间复杂度
$$
T(n) = aT(n/b) + f(n)
$$
其中常数 a, b 满足： $a \geq 1$且 $b > 1$

2. 主定理：
>令 $a \ge 1$， $b>1$ 为两个常数，$f(n)$ 是一个函数，$T(n)$ 定义在自然数上，满足如上所示的递归式（其中将 $n/b$ 解释为 $\left\lfloor n/b \right\rfloor$ 或者 $\left\lceil n/b \right\rceil$，则 $T(n)$ 有如下渐进界：
>1. 若对某个常数 $\epsilon > 0$ 有 $f(n)=O(n^{\log_b a-\epsilon})$，则 $T(n) = \Theta(n^{\log_b a})$
>2. 若 $f(n)=\Theta(n^{\log_b a})$，则 $T(n) = \Theta(n^{\log_b a} \lg n)$
>3. 若对某个常数 $\epsilon > 0$ 有 $f(n) = \Omega(n^{\log_b a + \epsilon})$，且对某个常数 $c < 1$ 和所有足够大的 n 有 $af(n/b) \le cf(n)$，则 $T(n) = \Theta(f(n))$

>[!summary] 
将函数 $f(n)$ 和递归树层数 $a^{\log_b n} = n^{\log_b a}$进行比较，若 $f(n)$ 渐进小于(相差一个**多项式** $n^\epsilon$ ) $n^{\log_b a}$，则取后者（情况1），若 $f(n)$ 渐进大于(相差一个**多项式** $n^\epsilon$ ) $n^{\log_b a}$，则取前者，若渐进相等，则再乘上一个 $\lg n$

3. 当然主方法也有无法判断的地方，并不适用于所有满足上述递推式的情况

4. 注意在比较 $f(n)$ 和 $n^{\log_b a}$ 时，必须**相差一个多项式** $n^\epsilon$，否则主方法失效

主方法的推广：（Akra-Bazzi方法）
$$
T(x) = 
\begin{cases}
\Theta(1) \quad 1 \le x \le x_0 \\
\\
\sum_{i = 1}^k a_iT(b_ix)+f(x) \quad x \ge x_0
\end{cases}
$$
其中 
- $x \ge 1$ 为一个实数
- $x_0$ 为一个常数，满足对 $i = 1, 2, \ldots, k$，$x_0 \ge 1/b_i$ 且 $x_0 \ge 1/(1 - b_i)$
- 对 $i = 1, 2, \ldots, k$，$a_i$ 为正常数，$b_i$ 为 $(0, 1)$上的常数
- $k$ 为一个正整数常数
- $f(x)$ 为一个非负函数，满足**多项式增长条件**，
则有
$$
T(n) = \Theta(x^p(1+\int^{1}_{x} \frac{f(u)}{u^{p+1}} {\rm d}x))
$$
其中实数 p 满足
$$
\sum_{i=1}^k a_i b_i^p = 1
$$

## 1.4 母函数法

>适用于求解线性递推式（一些非线性的也可以用），较简单，略
