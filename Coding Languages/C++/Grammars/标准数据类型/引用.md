# 1. 基础性质

1. 声明格式：
```c++
typeName a; // 声明变量a
typeName &a1 = a; // 声明引用a1
cout << &a1; // 输出a1所引用的变量a的地址，这里的&为取地址运算符
cout << a1; // 输出a1即a的内容
```

2. 必须在声明引用变量时初始化（类似于常量指针）
```c++
int &A = a;
// int *const p = &a;
```
使用`A`时，相当于使用`*p`

3. 引用变量一旦初始化，就不能再去引用其它变量（即引用变量不能被赋值）
4. 假如有如下代码：
```c++
int a = 0, b;
int *p = &a;
int &A = *p; // 这时A所引用的是a
p = &b; // 值改变了p的指向，没有改变A
```

5. 可以把引用使用于函数参数传递

# 2. 高级性质

## 2.1 常量引用

>*为避免引用参数在函数中被修改，应该使用常量引用*

1. **临时变量**：当函数的形参与实参类型不匹配时，会创建一个临时变量（实参的自动类型转换），并且将临时变量按值传递给形参，当前**仅当参数为const引用时**，才会允许这么操作
2. **创建临时变量的情况**：
	1. 实参的类型正确，但不是左值（如`x + 1.0`）
	2. 实参的类型不正确，但可以转换为正确的类型
3. **右值引用**（用于移动构造函数） ^8bd581
4. 常量引用将不允许使用别名对原名进行修改（和常量指针类似）
5. 常量引用可引用常量(`"Hello"`, `1123`等)及表达式（当为常量时，将创建一个临时变量）

## 2.2 引用与结构

>*引用主要是用于结构和类的，可以节省时间和内存，并且在函数参数中最好尽可能多的使用引用*

## 2.3 返回引用的函数

1. 应该避免返回函数终止时不再存在的内存单元引用(如函数中的局部变量)（指针同理）
2. 最好返回一个作为参数传递给函数的引用，如：
```c++
const int& clone(int& ft)
{
	int *pt; // 创建了一个无名变量，需要被delete释放内存
	*pt = ft;
	return *pt; // 返回该无名变量的引用
}
int a = 1;
int& jolly = clone(a); // jolly成为无名变量的引用, 可以看作为其命名
delete jolly;
```

^691363

>[!attention] 
注意，在函数`clone`中声明的指针`pt`指向的内存块是需要被释放的！（但是在有些保守的编译器中会返回"使用了未初始化的局部变量"的错误）

3. **把const用于引用返回类型**：当函数返回引用类型并且不希望它被修改时，可以用const来保护函数返回的引用

## 2.4 对象、继承和引用

1. 派生类和基类：
	- 派生类（如`ofstream`类）继承[^继承]了基类（如`ostream`类）的方法
	- 派生类对象可以使用基类的特性
	- 基类引用可以指向派生类对象，而无需强制类型转换（如参数类型为ostream &的函数可以接受ostream对象或者ofstream对象）



[^继承]:使得能够将特性从一个类传递给另一个类的语言特性叫做继承