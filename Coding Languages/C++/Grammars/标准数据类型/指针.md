# 一、基础用法

1. 指向不同类型的指针的**长度相同**
2. 要在解引用指针之前，把指针初始化为一个确定的、适当的地址（最好在一开始先让指针指向NULL）
3. 不能简单地把整数赋给指针，必须强制转换为指针类型
4. 声明空指针：
```c++
typeName* p = nullptr;
```

>[!caution] 
>在C语言中，使用`NULL`表示空指针，但是存在一个`NULL`到0的隐式转换函数，导致在C++函数重载时，会优先将`NULL`匹配为`int`类型，而非指针类型，有可能引发错误；而`nullptr`则没有这种问题

5. 不能将不同类型的指针相互赋值，但可以通过强制类型转换来实现
```c++
int x = 1;
double* d = (double*)&x;
```
但是这样通常得不到想要的值，不应该使用(除非是想输出`char*`类型的地址时使用)

# 二、相关函数

## 2.1 `new`
^d0a602

### 2.1.1 使用`new`分配内存

1. 格式：
```c++
int *p = new int; // 分配内存
int *p = new int(6); // 分配内存并初始化，也可以用{}
```
2. 相当于定义了一个无名称的变量，仅仅记录了它的地址p

### 2.1.2 使用`new`来创建动态数组

1. 格式：
```c++
int *psome = new int [size]; // 这里的size不需要是常量，可以根据需要自主调配
int *psome = new int [4] { 1, 34, 2 ,6}; // 分配内存并初始化
```

2. 需要用`delete []`来释放内存(整个数组的内存)，如：
```c++
delete [] psome;
```

3. 注意**指针数组**和**数组指针**是不一样的概念，前者是一个由指针组成的数组，而后者是指向数组的指针
```c++
int* p = new int[10]; // 一个大小为10的指针数组
int (*p)[10]; // 一个指向含有10个元素的数组的指针
```
又如，在`int a[10][10]`中，`a`和`a[0]`的值是相同的，但是两者类型不同，`a`是一个指向一个包含10个元素的数组的首地址的指针，`a[0]`是指向第0排的第一个元素地址的指针(整型指针)

>[!summary]
>定义的`psome`指针内容是一个地址，该地址由`new`分配，且位于一个名为堆的位置，是`new`将`psome`与该地址建立起联系，在`psome`消亡后，这个地址所在的内容并不会随之消亡，需要使用`delete`来解除对这个地址的占用，否则，当数据足够多时，”堆“中的内存将被全部占用，从而引发程序崩溃

### 2.1.3 使用`new`创建动态结构体

1. 格式：
```c++
struct things
{
	int good;
	int bad;
}grubnose = {3, 435};//定义结构体
things *p = new things;
```
2. 使用`*p`访问结构体本身
3. 使用`(*p).good`或者`p->good`访问结构体成员`good`

### 2.1.4 使用new创建类对象

1. 格式：
```c++
className* p = new className;
className* p = new className(……);
```
第一种方法将调用默认构造函数创建一个无名对象，再让p指向该对象；
第二种方法将根据参数列表自动选择需要的构造函数，并进行必要的自动类型转换

2. 使用new创建的类对象和一般数据类型变量相同，需要使用delete来显式释放内存
3. 使用`->`来调用类成员函数，如:
```c++
p->member();
```

### 2.1.5 定位new运算符

>*用于指定要分配内存的位置*

1. 包含头文件`new`
2. 格式：
```c++
char buffer[500];
int *p = new (buffer) int[20];
```
这里提供一个静态数组来为定位new运算符提供内存空间，从buffer中分配空间给数组p

3. 定位new运算符使用传递给它的地址，**不跟踪**哪些内存单元已经使用，**不查找**未使用的内存块，需要程序员自己规划（也就是说默认情况下都从给出的地址开始向后使用内存单元）
4. **不能释放**使用定位new运算符来分配的内存（因为delete只能用于指向常规new运算符分配的堆内存），当上面例子中的buffer数组是由常规new运算符创建的时候，则可以用delete来释放**整个**内存块

### 2.1.6 定位new运算符与类对象

>*使用定位new运算符定义类对象时，释放整个内存块并不会释放其中储存的类对象，因此需要显式地调用析构函数*

示例：
```c++
char * block = new char[512];
className* p1 = new(block) className;
className* p2 = new(block + sizeof(className)) className;

p2->~className();
p1->~className();
delete[] block;
```
需要以创建对象的顺序的相反顺序来删除对象（因为后创建的对象可能依赖于先创建的对象），且在释放所有对象后，再释放整个内存块

## 2.2 `delete`

1. 只能释放用常规`new`分配的内存（或者空指针），但不会删除指针本身
2. 不能重复释放同一块内存块
3. 不能使用`delete`释放声明变量所获得的内存
4. 如果忘记使用`delete`来删除内存，则当包含指针的内存被释放后，`new`所分配的内存将永远不能再次被调用，可能导致**内存耗尽而引起程序崩溃**

>[!WARNING]
>**隐式的分配的内存**（数据类型为指针或引用的函数中常见）一定要记得用delete释放掉（如[[引用#^691363|这个例子]]）

# 三、指针和其他

## 3.1 指针和数组

>*数组名和指针名基本可以等价使用，不同点在于，可以修改指针的值，而数组名是常量*

1. 对于数组`pa[3]`，它的名称`pa`本身代表了**数组第一个元素的地址**，而`&pa`则代表了整个数组的地址，它们在数值上是相等的，但是类型是不同的，如:
	1. 一种差别是，`pa + 1`为数组中下一个元素的地址，而`&pa + 1`为数组`pa`后面一个12字节内存块的地址（这里假定地址为4字节）
	2. 另一个差别是，要得到第一个元素的值，只需对pa解除一次引用，但需要对&pa解除两次引用：
```c++
**&pa == *pa == pa[0];
```

>[!summary]
>指针类型应该这样理解：
>对象名称只代表了对象的内容，而不能代表其地址，要想获取其地址，则必须用取地址运算符；
>对象的内容可以是某个地址，从而能够通过对象的内容来访问这个地址，此时该对象就是指针类型

## 3.2 指针和字符串

>*可以使用指针，像处理数组一样处理字符串*

1. 用`cout` 输出`char*`类型的指针，输出的是**指针内部的内容，而非地址**，对数组中的字符串名同理(因为C++中的`<<`对`char*`进行了[[运算符重载]])
2. `cout`对数组中的字符串、用引号括起的字符串常量、用指针描述的字符串，处理方式一致（因为都是代表字符串的地址），都是***先读取第一个元素的地址，再依次输出，直到遇见`\0`为止***，如果想要输出地址，需要先强制转换为`int*`类型或者`void *`类型

## 3.3 指针和`const`

>***尽可能多使用const来保护数据***

### 3.3.1 指向常量的指针

1. 格式：
```c++
const typeName *p = variable;
typeName const *p = variable;
// 两种形式均可，注意 * 的位置
```
2. 对于`p`而言，`*p`是不可修改的常量，然而`p`所指向的变量并不一定是常量，因此有时可以通过其他途径来修改`p`所指向的变量
3. 可以将指向常量的指针指向常量或变量，但不能将普通指针指向常量（但可以通过[[类型转换#^73a73d|常量转换]]来实现）
4. 仅当只有一层间接关系（如指针直接指向变量地址）时，才能将非`const`地址或指针赋给`const`指针

### 3.3.2 常量指针

1. 格式：
```c++
typeName *const p;
```
2. 常量指针不能够修改指向的位置，因此必须初始化
3. 常量指针可以修改指向的变量

## 3.4 函数指针

>*详见[[函数#^b2d370|函数指针]]*

## 3.5 this指针
详见[[类#^143f2a|this指针]]

# 四、指针的推广：迭代器
详见[[01 reference/iterator|迭代器]]

# 五、智能指针

>*在函数中使用new创建指针时，往往会忘记使用delete删除它，问题在于指针只是一种普通的类型，不能够在消亡时释放它所指向的内存，这类似于类中的浅复制，因此需要更高级的类型来完善这个功能*

## 5.1 Basic

1. 当智能指针过期时，其智能指针将自动释放其指向的内存
2. Syntax：
```C++
auto_ptr<double> p (new double);
*p = 2.25;
auto_ptr<double> q = p; // Not recommmended
*q = 3.0;
```
3. 使用智能指针必须包括头文件`memory`
4. 共有三种智能指针：`auto_ptr share_ptr unique_ptr`
5. 智能指针包含一个explicit构造函数，因此不能进行隐式类型转换
```c++
auto_ptr<double> p;
double* pp = new double;
// p = pp; Not allowed
p = auto_ptr<double>pp; // Allowed
// share_ptr<double> q = pp; Not allowed 
share_ptr<double> q(pp); // Allowed
```
6. 智能指针不能指向非堆类型，因为delete只能删除堆内存
```c++
string s = "Hello, world!";
// auto_ptr<string> ss(s);  Not allowed
```

## 5.2 注意事项

1. 避免使用`auto_ptr`，因为可能不经意就将两个`auto_ptr`指针指向同一个内存块，就有可能会删除两次，引起问题
2. 为了避免1中的问题，有两种解决方案：
	1. 建立**所有权**概念：只让一个智能指针拥有特定的内存块，当该指针消亡时，如果还有其他的指针指向同样的内存块，则将所有权转让给它，否则调用delete函数释放该内存块。`auto_ptr`和`unique_ptr`采用这种策略，但后者更加严格
	2. 创建智能更高的指针，跟踪引用特定内存块的次数，当指针消亡时，计数减一或者调用delete函数。`share_ptr`使用这种策略
```c++
auto_ptr<double> p1(new double(2.2));
auto_ptr<double> p2;
p2 = p1;
```
第三行将被认为是合法的，但是此时p1将失去对内存的所有权，若调用p1，将出现错误
```c++
unique_ptr<double> p3(new double(2.2));
unique_ptr<double> p4;
p4 = p3;
```
这里的第三行将被认为是不合法的，将不能够通过编译