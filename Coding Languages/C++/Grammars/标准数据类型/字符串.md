## c风格字符串

^5c792c

1. 以`\0`结尾
2. 读入字符串时，自动在结尾补上`\0`，如：
```c++
char boss[8] = "Bozo";
// boss[0] = 'B', boss[1] = 'o', boss[2] = 'z', boss[3] = 'o'
// boss[4] = '\0', 此处\0是自动补上的字符
// boss[5] = boss[6] = boss[7] = '\0', 此处\0是剩余空间自动赋值的字符
```
3. `'S'`和`"S"`不相同，前者为字符串编码的另一种表示形式，后者为字符`S`和`\0`构成的字符串
4. 任何两个由空白字符分隔的字符串常量被自动拼接成一个，如以下等价：
```c++
cout << "hello," "world!";
cout << "hello,"
"world!";
cout << "hello,world!";
```
5. 使用`cin`输入字符串时，遇到`\0`则停止输入，具体见[[cout & cin#^f435e2|字符串的输入输出]]
6. c风格字符串的比较：
	1. 不能直接用字符串的名称进行比较（因为字符串名称仅仅代表了字符串的地址，用引号括起来的字符串常量同理）
	2. 应该使用`strcmp`进行比较（详见[[cstring#^92ac06|函数strcmp()]]）
7. **字符串变量**并不保存在对象中，而是单独**保存在堆内存中**，对象仅保存了指出到哪里去查找字符串的信息
8. **字符串常量**保存在内存的data段中，只读，不可修改（因此不能通过索引修改内容，也不能作为`strcpy`等函数的第一个参数）
9. 字符串常量可以使用常量char型指针指向，但不能使用一般的char型指针指向；并且常量指针可以改变其指向位置
```c++
const char* s = "Hello, C++!"; // valid
// char* s = "Hello, C++!"; invalid
cout << s; // output: Hello, C++!
++s;
cout << s; // output: ello, C++!
```


## string类

^a7e6d8

>*使用string类更安全、方便*

1. `string`相关函数在头文件[[cstring|cstring]]中 
2. `string`类型可进行拼接，赋值
3. `string`对象不使用`\0`来标记字符串末尾
4. `string`类型字符串的比较：
	1. 使用`string`类重载符`!=`（要保证至少一个操作数为`string`对象），如：
```c++
string word = "hello";
while(word != "mate")
{
	……
}
```

^b472d1

## 原始字符串

>*在原始字符串中，字符就表示它自己*

1. 使用`"(`和`)"`作定界符，前缀`R`来标识原始字符串，如：
```c++
cout << R"(Jim "King" Tutt uses "\n" instead of endl.)" << endl
```
2. 如果在原始字符串中含有`)"`则可以在`"`和`(`之间增加任意几个字符，同时在结尾处的`)`和`"`之间增添相同的字符，如：
```c++
cout << R"+*(……)+*" << endl;
```

