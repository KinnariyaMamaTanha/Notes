# 一、函数原型

1. 函数原型中可以不写参数名，并且参数名也不一定要和函数定义中的相同
2. 函数原型中的自动转换： ^0b3168
	1. 原型通常自动把被传递的参数强制转换为期望的类型（当形参和实参不匹配时）
	2. 但[[函数#^47636e|函数重载]]将不允许某些自动强制类型转换
	3. 并且仅当兼容时，原型化才会导致类型转换，如原型不会把整数转换为结构或指针

# 二、函数与数组

1. 使用`const`避免函数改变原始数组，如：
```c++
void func(const double array[], int size);
```
这样参数`array[]`就被定义为了`const double*`类型（指向常量的指针），从而无法被修改

2. 可以使用两个指针来传递数组，如：
```c++
void func(int* begin, int* end);
```

这里`begin`指向第一个元素的地址，`end`一般规定为指向最后一个元素的后一个地址（和[[C++/Data Structure/iterator|iterator]]中的`end()`函数类似）(这样方便计算长度等操作)

这时，对于数组`array[size]`，`begin = array, end = array + size`，且`end - begin`等于数组的元素数目

3. 可以**在形式上**直接指定传入数组的大小(即方括号中的参数是**无意义的**)
```c++
int func(int array[10]); 
// 这将指定传入的数组的大小为10，但是仍然可以传入其它大小的数组
```

# 三、函数与二维数组

>*由于二维数组实际上是指针的数组，所以在调用二维数组时有格外的要求*

>[!tip] 二维数组的理解
>二维数组`a[m][n]`实际上是m个指向“拥有n个元素的数组”的指针构成的数组，其中，每一个`a[i]`都是一个指针，共m个，每一个指针`a + i`都指向一个数组，用`*(a + i)[n]`或`a[i][n]`表示，此时，a就是一个指向指针的指针

1. 格式：
```c++
typeName func(typeName (*array)[column], int size); 
// *array表示参数是指针，colomn表示每个指针指向几个数据，不可省略；不可去掉小括号
typeName func(typeName array[][column], int size);
```
这里如果写成了`*array[colomn]`，则表示一个由column个指针组成的数组(`typename* array[colomn]`)，而不是由指向**由column个数据构成的数组**的指针所构成的数组(`typename array[]`)，这里`array`都是指针，`size`变量规定了行数，`column`变量规定了列数

2. 使用：
	1. `array`表示指向第一行所代表的数组的指针
	2. `array + r`表示指向第r行的那个数组的指针
	3. `*(array + r)`或`array[r]`表示第r行的那个数组（也是指针）
	4. `*(array + r) + c`或`array[r] + c`表示指向第r行的那个数组的第c个元素的指针
	5. `*(*(array + r) + c)`或`*(array[r] + c)`或`array[r][c]`表示第r行的那个数组的第c个元素
3. 实现传递任意行任意列的二维数组：
```c++
// 方案一
typeName func(typeName** array, int row, int column);
```
但是这种方案中的`array`**不能是数组名**，只能是二重指针
```c++
// 方案二
typeName func(typeName* array, int row, int column);
```
这种方案在传递实参的时候需要进行强制类型转换

# 四、函数与[[Coding Languages/C++/Grammars/标准数据类型/字符串#^5c792c|C风格字符串]]

>*由于C风格字符串有内置的结束字符`\0`，所以有时不必把字符串长度作为参数传递给函数*

1. 若要返回字符串，可以使用`new`来新建一个字符串（记得在结尾标上`\0`），并且返回该字符串的首字符的**地址**，比直接返回字符串更方便(记得释放内存)
2. 读取字符串实质就是读取指针(因为C++中cout, cin等都可以接受一个char\*类型的数据，并进行特殊处理)

# 五、函数与结构体

>*由于结构名只是结构体的名称，所以和处理普通变量差不多*

传递和返回结构体：
1. **按值传递**：当结构体较小时适合使用
2. **传递指针**：当结构体较大时用来节省时间空间
	1. 将形参声明为指向结构体的指针类型
	2. 使用间接成员运算符`->`来访问成员，如`p->member`
3. **传递引用**：见[[引用|引用]] （推荐使用，比按值传递节省空间时间，比指针更方便）

# 六、函数与[[Coding Languages/C++/Grammars/标准数据类型/字符串#^a7e6d8|string对象]]

>*代替二维的char类型数组*

# 七、函数指针
^b2d370

1. 函数名称就代表了函数地址，就像数组一样（实际上数组可以看作特殊的函数）
2. **声明函数指针**：
```c++
typeName1 func(typeName2); // 函数原型
typeName1 (*p)(typeName2); // 声明函数指针, 注意括号不可省
p = func; // 使函数指针p指向函数func, 或者用auto:
auto pp = func;
```

3. **函数指针数组**：
```c++
const double* f1(double [], int); // 用[]代表数组，即指针
const double* f2(double* a, int b);
const double* f3(double a[], int y); // 声明三个相同类型const double *的函数
const double* (*p1)(double*, int); // 声明一个函数指针
p1 = f1; // 给函数指针赋值
auto p2 = f2; // 使用自动类型推断声明函数指针，并初始化
const double* (*pa[3])(double*, int) = { f1, f2, f3 }; // 声明并初始化一函数指针数组
double array[3] = { 1.0, 2.2, 3 };
for(int i = 0; i < 3; ++i)
	cout << (*pa[i])(array, 3); // 依次调用f1,f2,f3三个函数
	auto pd = &pa; // 声明一个指向函数数组pa的指针
	const double* (*(*pd)[3])(double*, int) = &pa; // 另一种声明方法
```

>[!warning]
>不能使用`auto`来自动类型推断一个数组，包括指针数组、函数指针数组，auto只能用于单值初始化，并且不能同时自动推断多种类型

4. 使用`typedef`来简化声明
```c++
typedef const double * (*p_func)(double *, int);//类型重命名为p_func
p_func p1 = f1; // 将p1的声明简化了
```

5. 使用函数指针传递函数参数：
```c++
int add(int a, int b)
{
	return a + b;
}

int sub(int a, int b)
{
	return a - b;
}

int mul(int a, int b)
{
	return a / b;
}

int op(int a, int b, int (*func)(int, int) = add)
{
	return func(a, b);
}
```
此时，就能通过`op`函数来调用其它函数了，如 `op(1, 2, add)` 将返回 `3` ，`op(2, 3, sub)` 将返回 `-1` ，`op(9, 4, mul)` 将返回 `2` ；另外默认使用 `add` 函数作为参数。这样就和Python中的函数传递相似了

# 八、C++中函数的新特性

## 8.1 内联函数

^f90d51

>*如果函数运行时间较短而经常被使用，则可以使用内联函数来节省调用函数的时间，尽管会消耗更多内存*

1. 格式：
```c++
inline func();
```
即在函数**声明**前加上关键字inline或者在函数**定义**前加上关键字inline(任意一个即可)

2. 内联函数**不能递归**
3. 内联函数最好写在同一行，最好直接写出定义，而不是先写出原型，再写定义
4. 内联函数也是按值传递参数
5. 应该多使用内联函数来代替宏
6. 在[[单独编译|多文件编程]]时，内联函数必须在每个使用它的文件中都被定义，最好直接放在头文件中（因为内联函数的链接性是内部的）

## 8.2 使用引用参数的函数

### 8.2.1 引用

>*详见[[引用|引用]]*

### 8.2.2 何时使用引用参数

1. 使用引用的目的
	1. 修改调用函数中的数据对象
	2. 通过传递引用来提高运行速度
2. 何时使用

- 对使用传递的值但**不修改**的函数

|数据对象|使用方案|
|:---|:---|
|很小 |按值传递|
|数组|只能使用指针|
|较大的结构体|const引用或const指针|
|[[类]]对象|const引用|

- 对修改调用函数的实参的函数

|数据对象|使用方案|
|:---|:---|
|内置数据类型|指针|
|数组|只能使用指针|
|结构体|引用或指针|
|[[类]]对象|引用|

## 8.3 默认参数

1. 设置格式（在函数原型中声明，函数定义与普通函数一致）：
```c++
char* left(const char*, int n = 1);
```
这个函数`left`默认抽取读取的参数的最左边的一位

2. 函数的有默认值的参数必须全部集中在参数列表的右侧，如：
```c++
void func(const int*, int n = 1, int m = 2);
```
当调用函数时，若未读取到足够个数的实参，则会从左往右依次给形参赋值，不够的就使用默认值

3. 在声明和定义中**只能有一处**指定默认参数，若有两处，则报错
4. 在同一个源文件中，每个函数的每一个参数只能有一个默认值，但是在不同的源文件中则可以有**多个不同的默认值**

## 8.4 函数重载

^47636e

>[!SUMMARY]
>1. 函数重载允许多个同名函数的存在，并通过上下文确定调用哪个函数
>2. 判断能否重载时，站在编译器的角度思考

- C++允许定义名称相同的函数，条件是特征标（参数数目，参数类型等）不同
- 当没有匹配的原型的时候，编译器会尝试标准类型转换，但如果有多个函数可以适应转换后的结果时，将会报错
- 即使特征标看似不同，如果有变量可以同时匹配多个函数时，仍然会报错：
```c++
double cube(double x);
double cube(double &x);
```
因此类型引用和类型被视作**同一个特征标**，且**不区分const和非const变量**

- **特征标相同，但返回类型不同**的函数不允许重载，但**特征标和返回类型都不同**的函数允许重载

## 8.5 函数模板

>*当同一算法需要且可以运用于不同数据类型时，使用函数模板*

### 8.5.1 基本用法

1.  格式：
```c++
template <typename AnyType> // typename也可以换做class
void Swap(AnyType &a, AnyType &b)
{
	AnyType temp;
	temp = a;
	a = b;
	b = temp;
}
```
2. 当不考虑用户自定义的类时，应该使用 `typename` 而不是 `class` （尽管多数时候它们等价，还是建议多使用 `class` ）
3. **重载模板**：结合函数重载与函数模板
4. 函数模板也有很多局限，有些运算符可能并不能适用于所有数据类型，或者在不同数据类型中的含义不同（需要[[运算符重载|运算符重载]]）

### 8.5.2 显式具体化

>[!note] 为解决函数模板的局限性而创造
>当编译器找到与函数调用匹配的具体化定义时，将使用该定义而非模板

#### 8.5.2.1 **第三代具体化**

1. 对给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数及其重载版本
2. 显式具体化的原型和定义应该以`template<>`开头，并通过名称来指出类型
3. 优先级：非模板函数 > 具体化模板 > 函数模板
```c++
void Swap(job &, job &); // 非模板函数

template <typename T>
void Swap(T &, T &); // 函数模板

template <> void Swap<job>(job &, job &); 
// 显式具体化原型，Swap<job>中的job表示是对job的具体化，job是可选的，也可以写成：
// template <> void Swap(job &, job &);
```

#### 8.5.2.2 **实例化与具体化**

^f96caf

- **实例化**：
	1. **隐式实例化**：函数模板本身不会生成函数定义，编译器使用模板为特定类型生成函数定义时，得到函数实例，这被称为**隐式实例化**
	2. **显式实例化**：直接命令编译器创建特定的实例
```c++
template void Swap<int>(int, int);
```
意为“使用`Swap()`模板生成`int`类型的函数定义”

- **具体化**：
>[!note] 隐式实例化、显式实例化，显式具体化统称为具体化
>它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述(函数模板就是一种通用描述)

```c++
template <> void Swap<int>(int &, int &);
template <> void Swap(int &, int &);
```
意为“不要使用`Swap()`模板来生成函数定义，而应使用专门为`int`类型显式地定义的函数定义”

显式具体化的函数原型必须要有自己的函数定义

#### 8.5.2.3 重载解析

>*详见[[重载解析|重载解析]]*

### 8.5.3 确定变量类型

#### 8.5.3.1 关键字`decltype`

>*当无法在模板函数中确定对象的类型时使用*

```c++
template <typename T1, typename T2>
void func(T1 x, T2 y)
{
	decltype(x + y) z = x + y;
	return;
}
// decltype(expression) val;
```
`decltype`确定类型的过程：
1. expression是一个没有用括号括起来的标识符，则val的类型与该标识符相同(包括const等限定符)
2. expression是一个函数调用，则val的类型与函数返回类型相同（只检查函数原型，**不调用函数**）
3. expression是一个左值[^左值]，则val为指向其类型的引用（由于第一步已经排除了没有用括号括起来的标识符，所以在这步的expression有一种可能是用括号括起来的）
```c++
int x = 1;
decltype(x) y; // y的类型是int
decltype((x)) z; // z的类型是int&
```
4. 若前三步均不满足，则val的类型与expression的类型相同

#### 8.5.3.2 后置返回类型

格式：
```c++
template <typename T1, typename T2>
auto func(T1 x, T2 y) -> decltype(x + y) // 判断x + y的类型来确定函数类型
{
	return x + y;
}
```

# 九、函数和链接性

1. 所有函数的存储持续性都是**静态**的（整个程序执行期间都一直存在）
2. 默认函数的链接性是**外部**的，可以在文件间共享(内联函数除外)
3. 可以使用`static`将函数的链接性设置为内部的，必须**在原型和声明中同时使用**
4. 对非内联函数，多文件程序中，只能有一个文件包含该函数的定义，但**使用该函数的每个文件都应该包含其函数原型**(或原型紧跟定义)
```c++
// file1.cpp
#include <iostream>
void func()
{
	std::cout << "Hello, World!" << std::endl;
}

// file3.h
#include <iostream>
void func2()
{
	std::cout << "Hello, C++" << std::endl;
}

// file2.cpp
#include <iostream>
#include "file3.h"
extern void func(); // 包含函数原型，表示使用cpp中的函数func()
int main()
{
	func();
	func2(); // 不需要包含函数原型，因为在头文件中已经定义了
	return 0;
}
```

5. 对于内联函数，通常将其放在头文件中(因为内联函数的链接性是内部的)
6. **语言链接性**：在C语言和C++语言中，对函数的名称有不同的翻译，链接程序如果要在C++程序中使用C库中预编译的函数，就可能出现问题
```c++
extern "C" void func(); // 使用C语言链接性
extern void func(); // 默认使用C++语言链接性
extern "C++" void func(); // 使用C++语言链接性
```

# 十、`main()`函数

1. `main()`函数有两个形参，但是一般不给出
	1. 命令行参数：`cp` `filea` `fileb` ...
	2. 完整形式：`int main(int argc, char* argv[])`，其中`argc`为命令的个数（包括命令本身），`argv[]`是命令行参数数组，如：
```shell
$ myprogram
$ myprogram try cp
```
这里提前写入了一个名为`myprogram`的cpp文件，在第一行中，argc的值为1（包括了myprogram这个命令），`argv[]`中只包含一个数据`myprogram`；在第二行中，`argc`的值为3，`argv[]`中包含三个数据`myprogram` `try` `cp`

# 十一、常量表达式函数

> 常量表达式函数是可用于（但不一定能用于）常量表达式中的函数

1. 使用关键字`constexpr`
2. 函数体内只能有一个`return`语句，不能有进行其它操作的语句，但允许有类型别名、空语句等
```c++
constexpr int func() { return 10; }
constexpr bool odd(int n) { return (n % 2) ? true : false; }
```
其中`odd`函数当参数`n`为**常量**时，可以用于常量表达式；否则不能用于常量表达式

[^左值]: 左值英文全称为locator value，右值为read value. 左值是指有名称且可寻址的变量，可位于赋值运算符左侧和右侧，而右值指可提供数据值的数据(不一定能寻址)，只能位于赋值运算符右侧 