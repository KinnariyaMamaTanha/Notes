>*使用运算符函数实现运算符重载*

# 一、运算符函数

1. 格式：
```c++
operatorop(argument-list)
```
例如，`operator+()`将重载运算符`+`，`operator*()`将重载运算符`*`

2. `op`必须是有效的C++运算符，不能虚构一个新的符号
3. e.g:
```c++
// Time.h
class Time
{
private:
	int hours;
	int minutes;
public:
	Time();
	~Time();
	Time operator+(const Time & t) const;
}
```
```c++
// Time.cpp
Time Time::oprator+(const Time & t) const
{
	Time sum;
	sum.minutes = minutes + t.minutes;
	sum.hours = hours + t.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}
```
此后就可以把两个Time类的对象直接相加了，如：
```c++
Time time1(1, 20);
Time time2(2, 5);
Time total_time = time1 + time2;
```
此时运算符`+`左侧为调用对象，右侧为参数

# 二、重载限制

>[!note]
>1. 多数运算符可以通过上述方式重载
>2.  重载的运算符有时不必是成员函数，但必须至少有一个操作数是用户定义的类型

1. 重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。
2. 使用运算符时不能违反运算符原来的句法规则。（如二元运算符不能被重载为一元运算符）
3. 不能创建新的运算符
4. **不能重载**下面的运算符。

|运算符符号|运算符名称|
|:---|:---|
|sizeof|sizeof运算符|
|.|成员运算符|
|.\*|成员指针运算符|
|::|作用域解析运算符|
|?:|**条件运算符**|
|typeid|一个RTTI运算符|
|const_cast|强制类型转换运算符|
|dynamic_cast|强制类型转换运算符|
|reinterpret_cast|强制类型转换运算符|
|static_cast|强制类型转换运算符|

5. 下表中所有运算符**均可重载**

|+|-|\*|/|%|^|
|:----:|:---:|:---:|:---:|:---:|:---:|
|&|\||~=|!|=|<|
|>|+=|-=|\*=|/=|%=|
|^=|&=|\|=|<<|>>|>>=|
|<<=|\==|!=|<=|>=|&&|
|\|\||++|--|,|->\*|->|
|()|\[]|new|delete|new\[]|delete\[]|

6. 下表运算符**只能通过成员函数重载**

|运算符符号|运算符名称|
|:---:|:---:|
|=|赋值运算符|
|()|函数调用运算符|
|\[]|下标运算符|
|->|通过指针访问类成员的运算符|

>[!attention]
>当重载运算符两边不均为类对象时，操作数的顺序不可更改，必须是左侧为类对象，右侧为其他类型对象，若要规避这种情况，则可以使用非成员运算符函数来重载运算符，此时该函数又必须是[友元函数](友元.md#^61a252)

^7a1a5c

7. 上述attention中两种运算符重载方法不可同时使用

# 三、一些技巧

1. 当重载运算符返回调用类型时，可以考虑使用构造函数来生成返回值
2. 当重载加法运算符函数返回一个对象时，以下语句将成立：
```c++
className a, b, c;
a + b = c; // 这个语句依然成立
```
其中第二个语句成立的原因是，先使用`a + b`将返回一个临时变量，再将c的值赋给该临时变量，为了使该语句不再成立，可以让重载函数返回一个const对象

# 四、一些运算符重载

## 4.1 赋值运算符

^95acf1

### 4.1.1 默认赋值运算符

1. 原型：
```c++
Class_name & Class_name::operator=(const Class_name &);
``` 
2. 将已有的对象赋值给另外一个已有的对象时，将调用赋值运算符
3. 初始化对象时不一定调用赋值运算符，见[何时调用默认赋值运算符](类.md#^27e690)

### 4.1.2 显式赋值运算符

以`StringBad`类为例（见[StringBad](类.md#^19804c)）
```c++
StringBad & StringBad::operator=(const StringBad & s)
{
	if(this == &s)
		return *this;
	delete[] str;
	len = s.len;
	str = new char[len + 1];
	strcpy(str, s.str);
	return *this;
}
```

代码说明：
1. 返回一个引用类类型是为了提供连续赋值的操作：
```c++
StringBad str1 = StringBad("C++");
StringBad str2 = str3 = str1;
```
2. 前两行用来检查自我赋值
3. 第三行先将str指向的内存释放，来接受新的地址
4. 余下的部分与复制构造函数相同

### 4.1.3 移动赋值运算符

^cf4005

使用[右值引用](引用.md#^8bd581)，可以使用移动赋值运算符，减少不必要的内存消耗
```c++
className& className::operator=(const className&& other)
{
	……
}
```

## 4.2 中括号运算符

>*用于实现使用中括号方法来访问某个特定位置的内存*

原型：
```c++
typeName& className::operator[](int i);
const typeName& className::operator[](int i);
```
例子：string类
1. 这里返回一个引用类型，使得能够使用公有接口来改变私有成员
2. 第二个原型将提供仅读取const类成员的功能（如果没有第二个原型的话，将不能读取const类对象）

## 4.3 自增自减运算符

```c++
// 公有成员原型
className& operator++(); // 前置++运算符，注意是引用
className operator++(int); // 后置++运算符，使用一个int参数来与前置++运算符区别，不需要真的写出来
```
在C++中，前置自增运算符将返回对象的引用，故而可以迭代使用：
```c++
++(++(++(++(++(a)))))
```
这里`a`的值将加5，当取消返回值的引用符号时，`++++++++++a`会返回`a + 5`的结果，但是`a`本身只会增加1.

但是后置自增运算符只会返回一个临时对象，故无法迭代使用
```c++
// ((((((a++)++)++)++)++)++)++
```
即使可以，`a`也只增加1，因为后面的`++`将作用在后置自增运算符返回的一个临时变量上
