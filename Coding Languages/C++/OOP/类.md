# 一、类的定义

1. 类规范由两部分构成：
	1. **类声明**：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口。
	2. **类方法定义**：描述如何实现类成员函数。
2. 接口（类定义）一般放在头文件中，实现（类方法的代码）放在源文件中
3. 类名首字母一般大写
4. 格式：
```c++
class className
{
	private: // 定义类的私有数据成员，可以包括函数原型或定义

	public: // 公有成员定义类方法，一般是函数原型

	protected: // 保护成员

}; // 必须加分号,结构体同理
```

# 二、类数据成员

## 2.1 访问控制

### 2.1.1 private & public

1. 使用类对象的程序都可以访问public部分，但必须通过public部分的成员函数（或[友元函数](友元.md#^61a252)）来访问private部分和protected部分的数据
2. **数据隐藏**：防止程序直接访问数据被称为数据隐藏
3. **封装**：将实现细节放在一起并将它们与抽象分开被称为封装
	1. **数据隐藏**是一种封装，将实现的细节隐藏在private部分中
	2. **将类函数定义和类声明放在不同的文件中**也是一种封装
4. 可以把成员函数放在private部分中，来处理不属于公共接口的实现细节（如实现[Queue](Coding%20Languages/C++/Data%20Structure/Linear%20Data%20Structure/Queue.md)时使用的`doublespace`函数）
5. C++中的[结构体](Coding%20Languages/C++/Grammars/标准数据类型/结构体.md)的默认访问类型为public（C++中的结构体可以被当作类来处理，而C中的不行），而类的默认访问类型为private（即没有指明private等关键字时，默认private）

### 2.1.2 protected

^0b7ae7

>[!warning]
>最好对**类数据成员**采用**私有访问控制**，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据；但**类成员函数**使用保护访问很有用

1. `protected`访问控制：在基类中使用`protected`关键句，能够使protected部分的数据成员被派生类访问
2. 对于成员函数而言，protected访问控制很有用，它让派生类能够访问公众不能使用的内部函数。例如，使用protected访问控制定义一些成员函数，使得能够在派生类中调用它们，从而来访问基类数据成员，这同时保证了外部无法使用这些函数来访问基类数据成员

### 2.1.3 using声明重新定义访问权限

^1fda20

>*在使用私有继承和保护继承时，如果要让基类方法可以直接被派生类对象调用，则可使用关键字using（就像名称空间一样）*

```c++
class Student: private std::string, private std::valarray<douuble>
{
	……
	public:
		using std::valarray<double>::min; // 只写成员名
		……
}
```
此后就可以直接使用min方法了：
```c++
Student A = {……}
std::cout << A.min;
```

>[!attention]
>using申明只能用于继承，不能用于包含

## 2.2 常量数据成员

^b997fc

>*不能直接定义一个[作用域为类的常量](类.md#^aae714)，但是可以为每个对象定义独有的常量数据成员*

1. 在构造函数中不能直接为const数据成员赋值（因为常量只能被初始化，不能被赋值，并且在进入构造函数函数体（[对象的构造过程](类.md#^2fd868)）前，常量对象已经被构造），但是可以使用**成员初始化列表**来完成，如：

```c++
class className
{
private:
	const int len;
	……
public:
	className(int n); // 构造函数
} // 类声明
className::className(int n) : len(n) // 成员初始化列表
{
	……
} // 构造函数定义
```
2. 只能在**构造函数**中使用成员初始化列表语法
3. 成员初始化列表可以使用逗号运算符来实现多个初始化，并且并不局限于常量数据成员 ^59aee7
```c++
className::className(int n, ……) : len(n), member1(……), …… // 此时冒号后的若干个表达式被逗号运算符联结为一个表达式
```

4. 当数据成员为**引用**类型时，也必须使用成员初始化列表（因为引用也必须在被创建时初始化）
5. 对于非静态常量数据成员，**必须**使用成员初始化列表
6. 对于本身就是类对象的成员来说，使用成员初始化列表的效率更高
7. 数据成员被成员初始化的顺序与它们**出现在类声明中的顺序**相同，与初始化器中的排列顺序无关（在某成员初始化的值与另一成员相关时尤其注意）
8. 也可以对内置类型使用成员初始化语法：
```c++
int a(24);
```
9. 通过成员初始化列表，有时甚至可以使函数体内不需要写入代码
```c++
className::className(int n, ……) : len{n} {}
```

## 2.3 嵌套类、结构体、枚举

>*正如[[线性表#^59c7aa|链表]]中的嵌套结构体一样，当然也可以嵌套类，并且语法基本一致*

1. 嵌套类**作用域**
	1. 在私有部分声明时，只能在类作用域中使用该嵌套类
	2. 在保护部分声明时，派生类将能够使用、创建嵌套类对象
	3. 在公有部分声明时，则该类、该类的派生类、外部都能使用该嵌套类。但在外部使用时，必须加上类限定符
2. **嵌套结构体和枚举变量**的作用域和嵌套类相同（因此可以通过公用枚举使用户能在外部使用枚举变量）
3. 在类模板中当然也可以嵌套类、类模板，见[嵌套类模板](类模板.md#^3a08c0)

# 三、类成员函数

## 3.1 基本性质

1. 定义成员函数时，使用作用域运算符解析`::`指出函数所属的类
```c++
typeName className::func(argument-list) // 一个成员函数的函数头
```
`className::func`被称为**限定名**，`func`被称为**非限定名** 
^3688a6
2. 成员函数的标识符`func()`具有[类作用域](类.md#^edaff8)，在`func()`中，同一个类的其他成员函数不必使用`::`来调用该方法
3. 在method中可以**直接**访问类的private成员
4. 定义在类声明中的函数将自动成为[内联函数](函数.md#^f90d51)，也可在类声明外定义一个内联成员函数：
```C++
inline className::func(argument-list) // 内联成员函数的函数头
```
由于内联函数必须在每个使用它的文件中被定义，因此**最好把内联函数定义放在定义类的头文件中**（而不是源文件中）

5. 使用类对象指针调用成员函数：
```c++
className *p;
p->func(); // 使用间接成员运算符->来调用成员函数
(*p).func() // 另一种写法
```

## 3.2 const成员函数

>*对const类型的类对象，必须保证对其使用的成员函数不会改变该对象的值，因此需要const成员函数*

1. 格式：
```c++
typeName func() const; // 函数头
typeName className::func() const
{
	...
} // 函数实现
```

2. 只要成员函数不修改类对象（不管是调用对象，还是参数中的类对象）的值，就应当把它声明为const成员函数，避免无意间出现调用了const类对象时引发的错误

## 3.3 特殊成员函数

^bdddbe

>特殊成员函数是编译器自动生成的成员函数
>
>*包括[默认构造函数](类.md#^0e6c09)、[默认析构函数](类.md#^de8558)、[复制构造函数](类.md#^4af599)、[赋值运算符](运算符重载.md#^95acf1)、地址运算符（均在没有定义的情况下）*
>
>C++11中提供了另外两个特殊成员函数：[移动赋值运算符](运算符重载.md#^cf4005)，[移动构造函数](类.md#^bcfb91)

## 3.4 静态类成员函数

1. 静态类成员函数**不能**由类对象调用
2. 不能在静态类成员函数中使用this指针
3. 如果在public部分声明静态类成员函数，则可以使用类名和作用域解析运算符来调用它
4. 由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员
5. 可以使用静态成员函数设置**类级**（classwide）标记，以控制某些类接口的行为

# 四、类的初始化

>[!note]
>无法像初始化标准类型一样初始化类对象，因为数据成员的访问状态是私有的

## 4.1 构造函数

1. 构造函数没有声明类型，名称**和类名相同**
2. 构造函数原型位于**public部分**
3. 程序声明对象时，将自动调用构造函数
4. 公有接口的参数不能与数据成员同名
5. 格式：
```c++
// file.h
class Stock
{
	private:
		string comany;
		int shares;
		double share_val;
	public:
		Stock(const string & co, int sh, double val); // 构造函数原型
};

// file.cpp
Stock::Stock(const string & co, int sh, double val)
{
	company = co;
	shares = sh;
	share_val = val;
} // 构造函数的定义

// main.cpp
Stock food = Stock("World Cabbage", 250, 1.25); // 显式初始化
Stock garment("Furry Marson", 125, 3.0); // 隐式初始化
Stock *pstock = new Stock("Electroshock Games", 100, 2.5); // 使用new动态分配内存
```

6. 无法通过对象来调用构造函数（因为先有构造函数构造了对象，才会有对象来调用函数）
7. 构造函数也可用于重置类对象（但正如第六点中说的，**不能**通过对象来调用构造函数）
```c++
#include <iostream>
using namespace std;
class A
{
private:
	int a;
	double d;
public:
	A(int x, double y): a(x), d(y) {}
	void show() const { cout << a << ' ' << d << endl; }
};

int main()
{
	A obj(12, 23.4);
	obj = A(2, 2.2);
	obj.show();
	return 0;
}
```

8. 只有一个参数的构造函数允许使用赋值语法将类对象初始化一个值（参考[转换函数](类.md#^dcb067)），如：
```c++
// 构造函数
Stock(int n);
// 声明对象
Stock stk = 6; // 这里隐式地调用了Stock(6)
```

## 4.2 复制构造函数

^4af599

^d0b889
 当使用一个类对象来**初始化**另一个类对象时，实际上自动生成并调用了一个隐藏的构造函数，除非重载了赋值运算符：（以上文Stock类为例）
```c++
Stock num = val;
// 等价于 Stock num = Stock(val);
```

构造函数函数头为：
```c++
Stock(const Stock &);
```
称为**复制构造函数**

### 4.2.1 何时调用

>*每当程序生成了对象副本时，编译器都将使用复制构造函数。*

1. 使用一个已有对象**创建并初始化对象时**
```c++
className x(y);
className x = y;
className x = className(y);
className* x = new className;
```
中间两种声明也有可能直接创建对象x，也有可能先用y创建一个临时对象后，再用该临时对象来创建`x`（此时将调用赋值运算符）；最后一种声明先创建一个匿名的对象，再将该对象的地址传递给x ^27e690

2. **按值传递**意味着创建原始变量的一个副本；**生成临时对象时**（如函数中按值返回一个类对象时），也将调用复制构造函数

>*为了节省时间空间，尽量传递引用*

### 4.2.2 默认复制构造函数的功能

>1. *默认复制构造函数逐个复制非静态成员的值（称为浅复制）*
>2. *静态成员属于整个类，因而不受影响*
>3. *对于本身就是类对象的成员，将使用该类的(默认)复制构造函数来进行复制*
>4. *由于默认复制构造函数按值复制，因此，当类数据成员中有指针时，将会出现问题，如：*

^7399a5

```c++
class StringBad
{
private:
	int length;
	char str*;
public:
	StringBad(const char* s) // 构造函数
	{
		length = strlen(s);
		str = new char*[length + 1];
		strcpy(str, s);
	}
	~StringBad()
	{
		delete[] str;
	}
}

StringBad str1 = StringBad("C++"); // 调用构造函数
StringBad str2 = str1; // 调用默认复制构造函数
```
此时，当`str1`消亡时，其数据成员将被删除，`str`指针指向的地址将被delete释放，但`str2`的指针`str`仍然指向该地址，因此极有可能出现错误（比如输出该处的内容时出现乱码，重复释放同一个位置的内存），解决方法是使用深度复制，见下节

### 4.2.3 显式复制构造函数

>*使用深度复制将**指针及其指向内容**全部复制给新的对象*。
>以上节中的类为例，解决方案是定义一个显式的复制构造函数：

```c++
StringBad(const StringBad& s)
{
	length = s.length;
	str = new char[length + 1];
	strcpy(str, s);
}
```

>[!warning] 
>复制构造函数的形参**只能是（常量）引用**；如果设计为值传递，则会引起复制构造函数的递归调用（因为值传递会创建一个临时变量，这个过程又会调用复制构造函数）

## 4.3 默认构造函数

^0e6c09

>*默认构造函数是在未显式提供初始值时，用来创建对象的构造函数*

1. 当且仅当没有提供**任何**构造函数时，编译器将自动提供默认构造函数，并且隐式地使用默认构造函数（该函数不含任何操作）
2. 若定义了构造函数后仍需要使用默认构造函数，则需要程序员来提供默认构造函数，可以通过有默认值的函数或函数重载来实现（但不能同时使用）
3. 隐式地调用默认构造函数时，不要用`()`（因为会被理解为声明一个函数）
4. 默认构造函数会随机给未初始化的对象的值赋值
5. **只能有一个默认构造函数**

## 4.4 析构函数

^de8558

>*用构造函数创建变量后，程序负责跟踪该变量，直到其过期为止，对象过期时，将自动调用析构函数来完成清理工作*

1. 析构函数名称为类名前加上一个`~`
2. 析构函数可以没有返回值和声明类型，且**必须没有参数**
3. 可将析构函数编写为不含任何操作的函数(此时不如直接使用编译器提供的默认析构函数)
4. 通常**不应在代码中显式的调用析构函数**，当对象为静态存储类对象、自动存储类对象或使用new创建的类对象并且数据消亡时，将自动调用析构函数（对于使用new创建的对象，需要显式地使用delete来释放，释放时自动调用析构函数）
5. 若程序员没用提供析构函数，则编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。
6. 在构造函数中使用了`new`来分配内存后，必须在析构函数中使用`delete`来释放内存

>[!attention]
>*每当有类对象消亡时，都会调用析构函数，而不管该类对象是什么种类，包括临时对象等等*

## 4.5 C++11的[列表初始化](初始化.md#^504369)

> *可将列表初始化用于类，只需要提供与某个构造函数的参数列表相匹配的内容*

## 4.6 [成员初始化列表](类.md#^b997fc)

>*用于非静态const数据成员、引用类型的数据成员和派生类的初始化*

1. 可以使用初始化列表来初始化[派生类对象的基类部分](#^165994)（使用基类的构造函数）、数据成员（直接使用成员名）
2. 在私有继承中只能使用子对象**类名**来初始化

对象的构造过程： ^2fd868
1. 按照数据成员的定义顺序依次构造每个数据成员，执行每个数据成员对应类的构造函数
2. 执行当前类的构造函数

列表初始化的意义：在类对象的构造函数调用时，若没有使用列表初始化，则会调用相应数据成员的**默认构造函数**；若使用，则根据初始化列表的实际参数来调用数据成员相应的构造函数，这能使数据成员的构造和初始化同时进行，提高了构造对象的效率

## 4.7 C++的类内初始化

可以直接在类声明中进行初始化：
```c++
class className
{
private:
	int m = 0;
	……
}
```
这和成员初始化列表等价，除非在构造函数中另外使用成员初始化列表，此时将按照**成员初始化列表**来赋值

## 4.8 移动构造函数

^bcfb91

通过[右值引用](引用.md#^8bd581)，可以实现对临时变量的直接接管：
```c++
class className
{
private:
	……
public:
	className(className && other);
};

className::className(className && other): ……
{
	……
}
```

# 五、this指针
^143f2a
>***this指针指向**用来调用成员函数的**对象***

1. 成员函数中使用的数据成员实际上是用this指针调用的，即`dataName`实际上是`this->dataName`的简写
2. 每个成员函数都有一个this指针，const成员函数中this指针为const类型
3. 可将`*this`作为调用对象的别名

# 六、类对象数组

1. 创建方法和标准类型对象数组相同
2. 初始化：
```c++
Stock stocks[4] = { Stock("Nanosmart", 12.5, 20),
				    Stock(),
				    Stock("Monolithic", 13.3, 100)};
```
这里一个含有4个Stock类的对象数组，stock\[0]和stock\[2]被构造函数显式地初始化，stock\[1]被显式地默认初始化，stock\[3]被隐式地默认初始化

>[!note] 初始化对象数组的方法
>首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有**默认构造函数**。

# 七、类作用域

^edaff8

>*在类中定义的名称的作用域都为整个类*

## 7.1 作用域为类的常量

^aae714

1. 不能在private中直接定义一个作用域为整个类的常量（但是可以声明[对象独有的常量](类.md#^b997fc)），因为声明类只是描述了对象的形式，并未创建对象，如以下代码不能定义一个作用域为类的常量：
```c++
class Bakery
{
private:
	const int MONTHS = 12;
	……
}
```

2. 为了创建一个有类作用域的**整型**常量，可以创建一个[枚举类型](枚举类型.md)来间接达到目的（相当于每个类对象中都有了一个相同值的整型常量）
```c++
class Bakery
{
private:
	enum {MONTHS = 12};
	double costs[MONTHS];
	……
}
```
用这种方式声明枚举并不会创建类数据成员，其效果为：在作用域为整个类的代码中遇到`MONTHS`时，编译器会自动用12代替它（但这种方法只能用于整型的常量）

3. 使用关键字static:(原理是，静态变量被所有类对象共享，而const保证其具有常量性质)
```c++
class Bakery
{
private:
	static const int MONTHS = 12;
	……
}
```
此时，`MONTHS`被定义为一个静态常量，和其他静态变量储存在一起，而不是储存在类对象中（即只有一个`MONTHS`变量，被所有Bakery类对象共用）

>[!warning] 
>只有当静态常量对象是**整型**时，才能够在类中赋初值；对于其它类型的静态常量对象，必须在类外赋初值（因为此时类中的语句只相当于一个**声明**）

## 7.2 静态成员变量

>[!attention]
>*不能在类声明中初始化静态成员变量，这是因为声明仅描述了如何分配内存，并不分配内存*

对于静态类成员变量，可以在类声明之外（且不在头文件中，应该在包含类方法的文件中）使用单独的语句来进行初始化，且不需要使用关键字static

但对于静态类成员**常量**，如果是**整型或枚举型**，则可以在类声明中初始化

>[!note]
>*静态变量的优点：节省空间。无论创建了多少个类对象，都只会创建一个静态类变量副本，可充当所有类对象都具有的值相同的数据成员*

>[!summary]
>1. 静态常量数据成员可以在类内初始化（即类内声明的同时初始化），也可以在类外，即类的实现文件中初始化，不能在构造函数中初始化，也不能在构造函数的初始化列表中初始化；
>2. 静态非常量数据成员只能在类外，即类的实现文件中初始化，也不能在构造函数中初始化，不能在构造函数的初始化列表中初始化；
>3. 非静态的常量数据成员不能在类内初始化，也不能在构造函数中初始化，而只能且必须在构造函数的初始化列表中初始化；
>4. 非静态的非常量数据成员不能在类内初始化，可以在构造函数中初始化，也可以在构造函数的初始化列表中初始化 

## 7.3 嵌套[结构体](结构体.md)和类

> *可以在类中嵌套结构体或类的声明，这种声明不会创建数据对象，而只是指定了可以在类中使用的类型*

1. 如果声明是在类的私有部分进行的，则只能在这个类使用被声明的类型
2. 如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型

# 八、类的[类型转换](类型转换.md)

## 8.1 构造函数

1. 当类的构造函数只有一个参数或者参数列表中只有一个不是默认参数时，可以进行自动类型转换，如：
```c++
// 构造函数
Stock(int n);
// 或者Stock(int n, int m = 1);
// 自动类型转换
Stock num = 123; // 这里将自动调用Stock(123)
```

2. 可以在构造函数原型前使用`explicit`来关闭上述隐式自动转换：
```c++
explicit Stock(int n);
```
但是显式强制转换仍然可以进行：
```c++
Stock num;
num = (Stock)123; // C风格
num = Stock(234); // C++风格
```

## 8.2 转换函数

^dcb067

>[!tip]
>*构造函数只能进行从某种类型到类类型的转换，若要实现相反的转换，需要使用转换函数*

1. 格式：
```c++
// file.h
operator typeName(); // typeName是要把类类型转换过去的类型，如double, int等等，可以理解为对运算符typeName()的重载

// file.cpp
operator typeName()
{
	return typeName(expression);
}
```

2. 转换函数必须是**类方法**
3. 转换函数不能指定返回类型
4. 转换函数不能有参数
5. 当缺少信息时（如有多个转换函数，但未指明具体转换为哪种类型时），编译器会显示**二义性错误**
6. 声明并定义了转换函数后，就可使用隐式地自动类型转换和显式地强制类型转换，也可以使用`explicit`来禁止自动类型转换：
```c++
explicit operator typaName();
```

>[!note]
>*最好多使用显式地类型转换，避免使用隐式地类型转换*

>[!attention]
>*过多的转换函数将导致二义性，因此最好多用重载赋值运算符*

# 九、类的动态内存分配

>[!note]
>动态内存分配能够有效减少内存负载，此时[析构函数](类.md#^de8558)变得必不可少

使用**指针**来储存数组位置（意味着类声明没有为数组本身分配存储空间，而是在构造函数中使用`new`来为数组分配空间。这避免了在类声明中预先定义数组的长度），示例：

```c++
// String.h
class String
{
private:
	int len;
	char * str;
public:
	String(char * s);
	~String();
};
```

^19804c

```c++
// String.cpp
String::String(char * s)
{
	len = std::strlen(s);
	str = new char[len + 1]; // strlen()函数返回字符串长度，但不包括结尾的\0，所以加1
	std::strcpy(str, s);
}

String::~String()
{
	delete[] str;
}
```
其他注意事项见[特殊成员函数](类.md#^bdddbe)

# 十、类继承

>*有三种继承关系：公有继承、私有继承、保护继承*
>
>*以及一种包含关系：派生类对象包含基类对象*

## 10.1 基类与派生类的关系

1. **基类指针**可以在不进行显式类型转换的情况下指向派生类对象；**基类引用**可以在不进行显式类型转换的情况下引用派生类对象。
2. 基类指针和引用**只能调用基类方法**，不能调用派生类方法（除了虚方法）
3. 不可以将基类对象和地址（包括基类指针）赋给**派生类引用和指针**（除非使用强制类型转换）
4. 派生类对象可以使用基类的public方法（包括友元函数）(在公有继承中)
5. 可以使用派生类对象为基类对象初始化或赋值（此时基类对象的值为派生类对象内置的基类对象的值），但不能使用基类对象为派生类对象初始化或赋值（除非定义了从基类到派生类的[转换函数](类.md#^dcb067)，或者重载了赋值运算符，或者使用强制类型转换）
6. 派生类不继承基类的赋值运算符，但是派生类的默认赋值运算符将对派生类数据成员进行浅复制，对基类数据成员调用基类赋值运算符
7. 可以将派生类对象赋给基类对象（基类对象将复制派生类对象的基类部分），但是不能将基类对象赋给派生类对象（除非提供了基类向派生类的类型转换函数）

## 10.2 公有继承

>[!note]
>公有继承使用 is-a 规则，在某些时候存在缺陷，如信息冗余，方法无意义等，此时需要使用[抽象基类](类.md#^62f90e)(然而在Python中只需要使用super()函数即可解决)

### 10.2.1 基本性质

1. 格式：
```c++
class Class2 : public Class1
{
	……
};
```

2. 使用公有派生，基类的公有成员将成为派生类的公有成员，基类的保护成员将成为派生类的保护成员；基类的私有部分也将成为派生类的一部分，但只能通过**基类**的公有和[保护方法](类.md#^0b7ae7)访问

### 10.2.2 构造函数

>*构造函数不能被继承，因而也不能是虚函数*

1. 派生类需要**重新定义自己的构造函数**（否则在需要使用派生类的构造函数的时候，将自动调用派生类的**默认**构造函数，再其中调用基类的**默认**构造函数），但不一定需要显式提供一个构造函数（有时默认构造函数就足够了）
2. 派生类可以按照需要定义自己的数据成员和成员函数
3. 派生类不能直接访问基类的私有成员，必须通过基类方法访问（然而可以直接访问保护成员），因此派生类的构造函数不能直接设置基类的成员，而必须使用基类的公有方法来访问（即使必须使用基类的构造函数，这也是将构造函数设为公有的一个原因），例如：
```c++
class Class1
{
private:
	int a;
	int b;
public:
	Class1(int x, int y); // 构造函数
};

class Class2 : public Class1
{
private:
	int c;
public:
	Class2(int x, int y, int z); // 构造函数
};

Class1::Class1(int x, int y)
{
	a = x;
	b = y;
} // Class1的构造函数

Class2::Class2(int x, int y, int z) : Class1(x, y) // 调用基类构造函数
{
	c = z;
}
```
这里使用**列表初始化**的方法来调用`Class1`的构造函数，从而访问基类的私有成员`a` `b`，如果不这样写的话，将会自动调用`Class1`的**默认构造函数**

4. 创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数
5. 派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数
6. 除虚基类外，类只能将值传递回相邻的基类，但后者可以使用相同的机制将信息传递给相邻的基类，依此类推
7. 构造函数不能是[虚函数](类.md#^b018e0)

### 10.2.3 多态公有继承

>*当基类与继承类需要使用相同名字但功能不同的成员函数时*
>实现方法：
>1. 在派生类中重新定义基类方法
>2. 使用虚方法

1. **虚方法** ^b018e0
	1. 在基类的函数声明前加上关键字`virtual`（当然也可以基类和派生类都加上，以便再次派生）
	2. 当使用了`virtual`时，通过指针或引用来调用成员函数时，程序将根据其**指向的对象的类型**来决定使用哪个类的成员函数；否则，将根据**指针或引用的类型**来决定
	3. 可以通过创建一个**指向基类对象的指针数组**，在一个数组中同时包含基类和派生类对象，即为**多态性**(但是不推荐使用)
	4. 应该使用**虚析构函数**，因为否则基类类型的指针或引用只能删除基类对象，而不能删除派生类对象，但构造函数不能是虚函数
2. 在派生类中调用基类的公有方法时，若基类和派生类中都有该名称的成员函数，则需要使用作用域解析符`::`，如`Class1::member()`，否则`member()`将会被认为是属于派生类的成员函数；若没有，则不需要使用（尤其是[在派生类中定义复制构造函数和赋值运算符时](类.md#^ad2f67)）

###  10.2.4 抽象基类（ABC）

^62f90e

>[!note]
>当两个类既拥有共性，又存在较大的区别导致直接使用公有继承不太恰当时，应该考虑使用抽象基类，即抽象出其共性来构造出一个基类，并将原始的两个类作为派生类使用

1. 当共有的方法无法在ABC中实现时（比如缺少数据成员），应该使用**纯虚函数**，如：
```c++
virtual typeName member(argument_list) = 0; 
// 对于const成员函数，应该在 = 0 前加上关键字const
virtual typeName member(argument_list) const = 0;
```

2. 当类声明中包含纯虚函数时，不能创建该类的对象，因此**抽象基类不能创建对象**

3. 要成为**真正的抽象基类**，**必须包含纯虚函数**，即使该函数能够在派生类中被单独定义，也需要它在ABC中被声明为纯虚函数(并且，纯虚函数被允许拥有定义)
 ^9f67c8
4. 如果基类的纯虚函数在子类中没有得到实现，则子类**仍然为抽象类**，不能被实例化

### 10.2.5 类继承与友元

以输出运算符为例：
```c++
class baseClass
{
private:
	……
public:
	friend ostream& operator<<(ostream& os, const baseClass& x);
	……
};

class derivedClass
{
private:
	……
public:
	friend ostream& operator<<(ostream& os, const derivedClass& x);
	……
};

ostream& operator<<(ostream& os, const derivedClass& x)
{
	using std::cout;
	cout << (const baseClass&) x; // 处理基类部分
	cout << ……; // 处理派生类独有部分
}
```
这里使用显式向上强制转换将`derivedClass&`类型的x转换为`baseClass&`类型的x，从而输出基类部分（因为`operator<<()`函数是友元函数，不在类作用域中，不能使用作用域解析符，所以不能指定使用`baseClass`中的输出运算符，可以通过类型转换来实现）

>[!summary]
>可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数
>
>也可以使用运算符dynamic_cast<>来进行强制类型转换（这种方式更佳）

### 10.2.6 联编与虚方法

^e26a28

>[!note] 
>将源代码中的函数调用解释为执行特定的函数代码块被称为**函数名联编**；
>在编译过程中进行联编称为**静态联编**；
>在程序运行时进行联编称为**动态联编**；
>虚方法的引入，导致动态联编是必要的

1. **向上强制转换**：将派生类转换为基类；**向下强制转换**：将基类转换为派生类
2. 允许隐式和显式向上强制转换和显式向下强制转换，但**不允许隐式向下强制转换**
3. 隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编
4. 编译器对非虚方法使用静态联编，对虚方法使用动态联编
5. 静态联编效率更高，且经常被使用，所以是C++的默认选择
6. 一种**虚函数机制**：
	1. 为每个对象添加一个隐藏成员
	2. 隐藏成员中储存了一个指向函数地址数组的指针
	3. 该函数地址数组被称为虚函数表(vtbl)，储存了为类对象声明的函数的地址
	4. 例如，基类对象包含一个指针，指向基类中所有**虚函数**的地址表；派生类对象包含一个指针，指向独立地址表，如果派生类提供了虚函数的新定义，将保存新函数的地址，否则将保存虚函数原始版本的地址。如果派生类定义了新的虚函数，则这些新的虚函数地址也会被添加到vtbl中。
	5. 调用虚函数时，先通过隐藏成员的指针访问vtbl，再找到相应的函数地址，最后前往该地址调用相应的函数
7. 虚函数注意事项：
	1. 构造函数不能是虚函数
	2. 基类的析构函数**必须是虚函数**
	3. 友元不能是虚函数（因为友元不在类作用域中）
	4. 当派生类中没有重新定义虚函数时，将沿派生链使用最新版本的虚函数
	5. 在派生类中重新定义继承的方法**不属于重载**，而是会**隐藏同名的基类方法**，不管参数特征标是否相同
	6. 当基类的虚函数被重载时，需要在派生类中声明所有重载版本，否则一些重载版本将会被隐藏，从而无法被派生类对象使用

### 10.2.7 动态内存分配

#### 10.2.7.1 派生类不使用new

>*不需要在派生类中定义显式析构函数、复制构造函数和赋值运算符，因为默认的函数已经足以完成相应任务*

#### 10.2.7.2 派生类使用new

^ad2f67

>*必须为派生类定义显式析构函数、复制构造函数和赋值运算符*

1. **显式析构函数**：只需要删除派生类中新增加的动态内存，基类中的动态内存将由隐式调用的基类析构函数删除
2. **复制构造函数**：由于派生类只能访问派生类独有的数据成员，所以需要使用基类的复制构造函数来为基类部分赋值，最好在**成员初始化列表**中使用
```c++
derivedClass::derivedClass(const derivedClass& x): baseClass(x)
{
	…… // 复制派生类数据成员
}
```
这里由于基类构造函数`baseClass()`的参数类型为`baseClass&`，故可以使用`derivedClass`类型的x作为实参(进行了一个隐式的类型转换)

3. **赋值运算符**：同复制构造函数，但是注意：在为基类部分赋值时，需要使用基类的赋值运算符（因此需要使用作用域解析符），如
```c++
derivedClass& derivedClass::operator=(const derivedClass& x)
{
	if(this = &x)
		return *this;
	baseClass::operator=(x); // 相当于*this = x; 但是后者会产生错误
	…… // 为派生类数据成员赋值
}
```
使用`*this = x`将会递归地调用派生类赋值运算符，产生错误

>[!summary]
>派生类数据成员由派生类处理，基类数据成员由基类成员函数处理

## 10.3 私有继承

>*私有继承与包含[^包含]相似，使用has-a关系*

1. 使用私有继承，可以使基类的public方法和protected方法都成为派生类的private方法（不同于公有继承，在公有继承中base class的public methods会成为derived class的public methods），即**derived class不继承base class的public methods**
2. 使用private inheritance，类将继承实现。即derived class将包含一个base class的组件，且derived class methods可以使用base class methods来访问base class组件
3. e.g. use `private`
```c++
class derivedClass: private baseClass1, private baseClass2……
{
	……
}
```
可以继承多个基类（multiple inheritance, MI），同时**私有继承将会提供相应的若干无名称基类对象(组件)**(但每种基类组件只有一个)

4. 私有继承中，只能在派生类的方法里使用基类的方法
5. 私有继承中，在不进行显式类型转换的情况下，不能将指向派生类的引用或指针赋给基类引用或指针

### 10.3.1 Initialization

^165994

1. 构造函数的初始化列表中需要使用继承的**基类的名称**(和公有继承中相同)：
```c++
derivedClass::derivedClass(): baseClass1(val), baseClass2(val) {}
```

### 10.3.2 methods

>*只能在derived class methods中使用base class methods*

1. 使用基类名和作用域运算符来调用base class methods，如
```c++
baseClass::method()
```

2. 使用[关键字using](类.md#^1fda20)

### 10.3.3 members

>*将this强制类型转换来访问base class object*

e.g.
```c++
(const baseClass) *this // 得到base class object
```

### 10.3.4 friends

因为友元函数不是类method，所以不能像method一样使用类名和`::`来访问，但是可以通过强制转换来使得base class的友元函数被调用(和public inheritance相似)
```c++
cout << (const baseClass &) *this; // 这里将自动调用baseClass的<<运算符
```

>[!tip]
>通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。


## 10.4 保护继承

>*使用保护继承时，基类的公有成员和保护成员都将成为派生类的**保护**成员*

| 各种继承方式     | 公有继承             | 私有继承             | 保护继承             |
| ---------------- | -------------------- | -------------------- | -------------------- |
| 公有成员变成     | 公有成员             | 私有成员             | 保护成员             |
| 私有成员     | 只能通过基类接口访问 | 只能通过基类接口访问 | 只能通过基类接口访问 |
| 保护成员变成     | 保护成员             | 私有成员             | 保护成员             |
| 能否隐式向上转换 | 是                   | 否                   | 只能在派生类中                     |

## 10.5 多重继承

>*一个类可以同时继承多个类，而且不一定使用一种继承方法*

```c++
class derivedClass: public baseClass1, private baseClass2, protected baseClass3, baseClass4
{
	……
}
```
当未指定继承类型时，默认使用私有继承

### 10.5.1 虚基类

^6b5f6d

>[!note]
>当一个派生类继承的多于一个的基类对象拥有相同的基类（如ABC）时，直接继承将使派生类同时拥有两个基类的基类子对象拷贝，如果只想要一个拷贝的话，可以使用虚基类

1. 格式：
```c++
class A {};
class B: virtual public A {};
class C: virtual public B {};
class D: public A, public B {};
```

2. 构造函数：
```c++
D::D(int a, int b, int c): A(a), B(a, b), C(a, b) {}
```
在使用虚基类时，可以在列表初始化中直接使用虚基类的构造函数（如果不使用，则D类成员的A类子对象将不会被初始化为a，而是会调用A类的默认构造函数来进行初始化）

3. **二义性**：在派生类中调用方法时，该方法可能在多个基类中都有，如果定义不一致，将会导致二义性，因此最好重新定义该方法，或者指明使用哪个基类的方法
4. 可以使用**模块化**的方式来避免在调用基类方法时，重复调用基类的基类的方法
```c++
class Worker
{
	……
	public:
		virtual void show() const;
	protected:
		virtual void Data() const;
};
class Waiter: virtual public Worker
{
	……
	public:
		virtual void show() const;
	protected:
		virtual void Data() const;
};
class Singer: virtual public Worker
{
	……
	public:
		virtual void show() const;
	protected:
		virtual void Data() const;
};
class SingingWaiter: public Singer, public Waiter
{
	……
	public:
		virtual void show() const;
	protected:
		virtual void Data() const;
};
void Worker::Data()
{
	// output the data of Worker
}
void Waiter::Data()
{
	// output the data of Waiter but not of Worker
}
void Singer::Data()
{
	// output the data of Singer but not of Worker
}
void SingingWaiter::Data()
{
	// output the data of SingingWaiter but not of Worker Waiter and     // Singer
}
void Worker::show()
{
	Worker::Data();
}
void Waiter::show()
{
	Worker::Data();
	Waiter::Data();
}
void Singer::show()
{
	Worker::Data();
	Singer::Data();
}
void SingingWaiter::show()
{
	Worker::Data();
	Singer::Data();
	Waiter::Data();
	SingingWaiter::Data(); // 可以直接写Data();
}
```
这里的每个`Data()`都是一个模块化的函数，可以通过它们的组合来达到预期目标
使用`protected`可以保证`Data()`成员函数只能被类自身及派生类调用，而不会被外界调用

5. 虚基类和支配
	1. 派生类中的名称优先于直接或间接祖先中的名称
	2. 两条派生链中的相同名称将导致二义性

>[!summary]
>当遇到有多个名称的时候，画一个派生关系图并向上查找，可确定是否有二义性

### 10.5.2 没有虚基类的情况

当派生类使用的方法在多个基类中都有时，使用限定名来指明使用哪一个

[^包含]:在一个类中直接定义另一个类的对象。包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。