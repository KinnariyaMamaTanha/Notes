>*并查集是等价类对集合的一个分划，基本操作为find(查)和union(并)*

# 一、存储实现

## 1.1 线性表存储

>时间复杂度：find()为$O(1)$，union()为$O(N)$

元素i的值为线性表中第i位上的等价类标识，则查找时只需要$O(1)$的时间复杂度，但合并两个集合时需要顺序遍历整个线性表，时间复杂度为$O(N)$

## 1.2 树存储

1. 每一个等价类被组织成一棵树，整个集合就是一个森林，查找时时间复杂度为$O(logN)$，合并时只需要将一棵树作为另一棵的子树，时间复杂度为$O(1)$
2. 不一定使用二叉树存储，可以是别的树
3. 每个结点只需要知道根结点是谁，因此采用[[Coding Languages/C++/Data Structure/Tree/Tree#^7e3722|双亲表示法]]，每个节点只储存父结点信息

![[并查集存储.png]]

# 二、运算实现

## 2.1 树存储

### 2.1.1 union()

在极端情况下，树存储的并查集的等价类将退化为一个线性表，从而使find()效率降低，所以不应该随意的进行union操作。优化方案：
1. 按规模并：将规模小的等价类作为规模大的等价类的子树
2. 按高度并：将高度小的等价类作为高度大的等价类的子树
3. 理想情况：根结点高度为1

存储规模/高度方案：将根结点的值令为负数，负代表是根结点，绝对值代表规模/高度

### 2.1.2 find()

采用**路径压缩**的方法，即每次查找，都将查找路径上的所有结点的父结点设置为根结点，这样下次查找时，效率就有可能变高

![[并查集路径压缩.png]]

路径压缩和按规模并能兼容，但和按高度并不能完全兼容（因为路径压缩可能改变高度，但是不能够重新有效计算出压缩后的高度）