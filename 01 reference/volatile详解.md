> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/didi1663478999/article/details/98523122?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169606484216777224420991%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169606484216777224420991&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-98523122-null-null.142^v94^chatsearchT3_1&utm_term=volatile&spm=1018.2226.3001.4187)

### [volatile](https://so.csdn.net/so/search?q=volatile&spm=1001.2101.3001.7020)

看了好多篇博客终于明白这个关键字到底是干嘛的… 让我综合所有的博客写一篇大家都能理解它的博客，要点赞呦！！！

volatile 是一个类型修饰符，作用是作为指令关键字，一般都是和 const 对应，**确保本条指令不会被编译器的优化而忽略。**

先从一个简单的栗子说起吧  
看下面一段代码 **（选择题中会考！！！）**

```c++
int main()
{
	int i = 10;
	int a = i;

	printf("%d", i);

	//下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道
	__asm
	{
		mov dword ptr[ebp - 4], 20h
	}
	int b = i;
	printf("i=%d", b);
	return 0;
}
```

然后，在 debug 版本模式运行程序，输出结果如下：

```c++
i = 10  
i = 32
```

然后在 release 版本模式运行下，输出结果如下：

```c++
i = 10  
i = 10
```

输出结果表明一个问题，在 release 模式下，编译器对代码进行了优化，具体优化结果如下：  
**由于编译器发现两次从 i 读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i 是一个寄存器变量或者表示一个端口数据就容易出错**

下面，我们把 i 的声明加上关键字 volatile，看看有什么变化没

```c++
int main()
{
	volatile int i = 10;
	int a = i;

	printf("%d", i);

	//下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道
	__asm
	{
		mov dword ptr[ebp - 4], 20h
	}
	int b = i;
	printf("i=%d", b);
	return 0;
}
```

分别在 debug 和 release 版本运行结果都是如下：

i = 10  
i = 32

这说明 volatile 发挥了它的作用。

```
这时，我们在配合一个例子再次深入理解一下
```

发薪资时，会计每次都把员工叫来登记他们的银行卡号；一次会计为了省事，没有即时登记，用了以前登记的银行卡号；刚好一个员工的银行卡丢了，已挂失该银行卡号；从而造成该员工领不到工资

员工 －－ 原始变量地址

银行卡号 －－ 原始变量在寄存器的备份

> volatile 应该解释为 “直接存取原始内存地址” 比较合适，“易变的”这种解释简直有点误导人；

#### 精华！！！！（一定要看）

> *   volatile 对应的变量可能在你的程序本身不知道的情况下发生改变
> *   比如多线程的程序，共同访问的内存当中，多个程序都可以操纵这个变量
> *   你自己的程序，是无法判定何时这个变量会发生变化
> *   还比如，他和一个外部设备的某个状态对应，当外部设备发生操作的时候，通过驱动程序和中断事件，系统改变了这个变量的数值，而你的程序并不知道。
> *   对于 volatile 类型的变量，系统每次用到他的时候都是直接从对应的内存当中提取，** 而不会利用 cache 当中的原有数值，** 以适应它的未知何时会发生的变化，系统对这种变量的处理不会做优化——显然也是因为它的数值随时都可能变化的情况。

让我们举几个 volatile 的例子

> 1）并行设备的硬件寄存器（如：状态寄存器）  
> 2）一个中断服务子程序中会访问到的非自动变量（Non-automatic variables)  
> 3）多线程应用中被几个任务共享的变量

#### 面试小题

**1）一个参数既可以是 const 还可以是 volatile 吗？解释为什么。**

是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为程序不应该试图去修改它。

**2）一个指针可以是 volatile 吗？解释为什么。**

是的。尽管这并不很常见。一个例子是当一个中断服务子程序修改一个指向一个 buffer 的指针时。

**3）下面的函数被用来计算某个整数的平方，它能实现预期设计目标吗？如果不能，试回答存在什么问题：**

```
int square(volatile int* &ptr)//这里参数应该申明为引用，不然函数体里只会使用副本，外部没法更改
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a*b;
}
```

由于 * ptr 的值可能在两次取值语句之间发生改变，因此 a 和 b 可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：

```
long square(volatile int*ptr)
{
    int a;
    a = *ptr;
    return a*a;
}
```